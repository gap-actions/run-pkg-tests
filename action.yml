name: 'Run package tests'
description: 'Run package tests'
inputs:
  coverage:
    description: 'Boolean that determines whether GAP is instructed to collect code coverage via the `--cover` argument'
    required: false
    default: 'true'
  testfile:
    description: 'Name of the GAP file to be read for executing the package tests (overrides TestFile in PackageInfo.g)'
    required: false
    default: ''
  mode:
    description: 'Value that determines which packages are loaded before the package is tested. The possible values are ''default'', ''onlyneeded'' or ''loadall''. The option ''default'' loads GAP with default set of package; ''onlyneeded'' loads only the needed dependencies of the package being tested; ''loadall'' executes LoadAllPackages() before the package being tested.'
    required: false
    default: 'default'
  warnings-as-errors:
    description: 'Boolean that determines whether any warnings produced whilst loading the package will be treated as errors'
    required: false
    default: 'true'
  pre-gap:
    description: 'Prefix for the ''GAP'' shell variable used by this action to launch GAP (e.g. setting this to ''valgrind --trace-children=yes --leak-check=full'' will run GAP through valgrind)'
    required: false
    default: ''

runs:
  using: "composite"
  steps:
      - name: "Validate input"
        shell: bash
        run: |
         validate_boolean() {
           local input=$1
           local option_name=$2
           if ! [[ "$input" =~ ^(true|false)$ ]]; then
             echo "Invalid value for option $option_name. Expected 'true' or 'false', but found '$input'"
             exit 1;
            fi
         }

         validate_mode () {
          if ! [[ "${{ inputs.mode }}" =~ ^(default|onlyneeded|loadall)$ ]]; then
            echo "Invalid value for option mode. Expected 'default', 'onlyneeded' or 'loadall' but found '${{ inputs.mode }}'"
            exit 1;
          fi
         }

         validate_mode
         validate_boolean "${{ inputs.coverage }}" coverage
         validate_boolean "${{ inputs.warnings-as-errors }}" warnings-as-errors

      - name: "Run tests"
        run: |
         set -ex

         GAPROOT=${GAPROOT-$HOME/gap}

         # set up a custom GAP root containing only this package, so that
         # we can force GAP to load the correct version of this package
         # (we already did that in build_pkg.sh, but we do it again here,
         # to allow the occasional instance where a package wants to also
         # run the tests of others packages, by invoking this script multiple
         # times in different directories)
         mkdir -p /tmp/gaproot/pkg/
         ln -f -s $PWD /tmp/gaproot/pkg/

         # start GAP with custom GAP root, to ensure correct package version is loaded
         GAP="$GAPROOT/gap -l /tmp/gaproot; --quitonbreak"

         # Prepend pre-gap prefix, if it exists
         if [[ ! -z "${{ inputs.pre-gap }}" ]]; then
             GAP="${{ inputs.pre-gap }} $GAP"
         fi

         if [ "${{ inputs.mode }}" = "onlyneeded" ]; then
             GAP="$GAP -A"
         fi

         # Unless explicitly turned off by setting the `coverage` input to `false`
         # we collect coverage data
         if ${{ inputs.coverage }}; then
             mkdir -p coverage
             GAP="$GAP --cover coverage/$(mktemp XXXXXX).coverage"
         fi

         cat > __TEST_RUNNNER__.g <<EOF

         GAP_TESTFILE:="${{ inputs.testfile }}";
         Read("PackageInfo.g");
         info := GAPInfo.PackageInfoCurrent;
         if IsEmpty(GAP_TESTFILE) or not IsExistingFile(GAP_TESTFILE) then
             GAP_TESTFILE := info.TestFile;
         fi;

         SetInfoLevel(InfoPackageLoading, PACKAGE_DEBUG);
         SetPackagePath(info.PackageName, "/tmp/gaproot/pkg/$(basename $PWD)");

         # Capture the output of loading
         output := "";
         output_stream := OutputTextString(output, true);
         SetPrintFormattingStatus(output_stream, false);
         OutputLogTo(output_stream);

         # Load the package with debug info
         if "${{ inputs.mode }}" = "onlyneeded" then
             LoadPackage(info.PackageName : OnlyNeeded);
         elif "${{ inputs.mode }}" = "loadall" then
             LoadPackage(info.PackageName);
             LoadAllPackages();
         else
             LoadPackage(info.PackageName);
         fi;

         OutputLogTo();
         CloseStream(output_stream);

         # Treat warnings as errors if specified
         ignored_prefixes := ["#I  HAP "];
         if ${{ inputs.warnings-as-errors }} then
             pos := 0;
             repeat
                 for prefix in ignored_prefixes do
                     l := Length(prefix);
                     if pos > l and output{[pos-l .. pos-1]} <> prefix then
                         Error("Warnings were found when loading the package");
                     fi;
                 od;
                 pos := PositionSublist(output, "warning", pos + 1);
             until pos = fail;
         fi;

         SetInfoLevel(InfoPackageLoading, PACKAGE_ERROR);
         Print("Now running tests from ", GAP_TESTFILE, "\n");
         if EndsWith(GAP_TESTFILE, ".tst") then
             QUIT_GAP(Test(GAP_TESTFILE, rec(compareFunction := "uptowhitespace")));
         else
             Read(GAP_TESTFILE);
             Error("Package TestFile did not exit gap");
         fi;
         EOF
         $GAP __TEST_RUNNNER__.g

        shell: bash
